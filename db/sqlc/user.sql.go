// Code generated by sqlc. DO NOT EDIT.
// source: user.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  id,
  fullname,
  username,
  email,
  role,
  gender,
  phone_number,
  password,
  address,
  avatar 
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id
`

type CreateUserParams struct {
	ID          uuid.UUID `json:"id"`
	Fullname    string    `json:"fullname"`
	Username    string    `json:"username"`
	Email       string    `json:"email"`
	Role        string    `json:"role"`
	Gender      string    `json:"gender"`
	PhoneNumber string    `json:"phone_number"`
	Password    string    `json:"password"`
	Address     string    `json:"address"`
	Avatar      string    `json:"avatar"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Fullname,
		arg.Username,
		arg.Email,
		arg.Role,
		arg.Gender,
		arg.PhoneNumber,
		arg.Password,
		arg.Address,
		arg.Avatar,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users 
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserAvatarById = `-- name: GetUserAvatarById :one
SELECT avatar FROM users WHERE users.id = $1 LIMIT 1
`

func (q *Queries) GetUserAvatarById(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserAvatarById, id)
	var avatar string
	err := row.Scan(&avatar)
	return avatar, err
}

const getUserById = `-- name: GetUserById :one
SELECT 
  id, 
  fullname, 
  username,
  email,
  role,
  gender,
  phone_number,
  address, 
  avatar,
  created_at, 
  updated_at
FROM users
WHERE users.id = $1 LIMIT 1
`

type GetUserByIdRow struct {
	ID          uuid.UUID `json:"id"`
	Fullname    string    `json:"fullname"`
	Username    string    `json:"username"`
	Email       string    `json:"email"`
	Role        string    `json:"role"`
	Gender      string    `json:"gender"`
	PhoneNumber string    `json:"phone_number"`
	Address     string    `json:"address"`
	Avatar      string    `json:"avatar"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.Gender,
		&i.PhoneNumber,
		&i.Address,
		&i.Avatar,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT 
  id, 
  fullname, 
  username,
  email,
  role,
  gender,
  phone_number,
  password,
  address, 
  avatar,
  created_at, 
  updated_at
FROM users
WHERE users.username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.Gender,
		&i.PhoneNumber,
		&i.Password,
		&i.Address,
		&i.Avatar,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserAvatarById = `-- name: UpdateUserAvatarById :exec
UPDATE users 
SET 
  avatar = $2,
  updated_at = $3
WHERE id = $1
`

type UpdateUserAvatarByIdParams struct {
	ID        uuid.UUID `json:"id"`
	Avatar    string    `json:"avatar"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateUserAvatarById(ctx context.Context, arg UpdateUserAvatarByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAvatarById, arg.ID, arg.Avatar, arg.UpdatedAt)
	return err
}

const updateUserById = `-- name: UpdateUserById :exec
UPDATE users
SET
  fullname = $2,
  email = $3,
  gender = $4,
  phone_number = $5,
  address = $6,
  updated_at = $7
WHERE id = $1
`

type UpdateUserByIdParams struct {
	ID          uuid.UUID `json:"id"`
	Fullname    string    `json:"fullname"`
	Email       string    `json:"email"`
	Gender      string    `json:"gender"`
	PhoneNumber string    `json:"phone_number"`
	Address     string    `json:"address"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) UpdateUserById(ctx context.Context, arg UpdateUserByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateUserById,
		arg.ID,
		arg.Fullname,
		arg.Email,
		arg.Gender,
		arg.PhoneNumber,
		arg.Address,
		arg.UpdatedAt,
	)
	return err
}

const updateUserPasswordById = `-- name: UpdateUserPasswordById :exec
UPDATE users 
SET 
  password = $2,
  updated_at = $3
WHERE id = $1
`

type UpdateUserPasswordByIdParams struct {
	ID        uuid.UUID `json:"id"`
	Password  string    `json:"password"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateUserPasswordById(ctx context.Context, arg UpdateUserPasswordByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPasswordById, arg.ID, arg.Password, arg.UpdatedAt)
	return err
}
